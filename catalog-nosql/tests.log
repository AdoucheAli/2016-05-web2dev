[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building catalog-nosql 2.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ catalog-nosql ---
[INFO] Deleting /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/target
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ catalog-nosql ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 3 resources
[INFO] Copying 0 resource
[INFO] 
[INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ catalog-nosql ---
[INFO] Compiling 9 source files to /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/target/classes
[WARNING] /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/src/main/java/com/store/catalog/mongo/config/CatalogMongoFactoryBean.java:[3,44] [deprecation] MongoFactoryBean in org.springframework.data.mongodb.core has been deprecated
[WARNING] /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/src/main/java/com/store/catalog/search/impl/ItemSearchDaoImpl.java:[6,37] [deprecation] CountResponse in org.elasticsearch.action.count has been deprecated
[WARNING] /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/src/main/java/com/store/catalog/mongo/config/CatalogMongoFactoryBean.java:[5,45] [deprecation] MongoFactoryBean in org.springframework.data.mongodb.core has been deprecated
[WARNING] /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/src/main/java/com/store/catalog/search/impl/ItemSearchDaoImpl.java:[209,8] [deprecation] CountResponse in org.elasticsearch.action.count has been deprecated
[WARNING] /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/src/main/java/com/store/catalog/search/impl/ItemSearchDaoImpl.java:[209,41] [deprecation] prepareCount(String...) in Client has been deprecated
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ catalog-nosql ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 9 resources
[INFO] skip non existing resourceDirectory /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/src/main/webapp
[INFO] 
[INFO] --- maven-compiler-plugin:2.5.1:testCompile (default-testCompile) @ catalog-nosql ---
[INFO] Compiling 5 source files to /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/target/test-classes
[INFO] 
[INFO] --- maven-surefire-plugin:2.19:test (default-test) @ catalog-nosql ---

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running com.store.catalog.search.impl.ItemSearchDaoTest
2016-04-04 10:58:34 main INFO  [junit.node] version[2.1.2], pid[9026], build[63c285e/2016-01-27T12:57:52Z]
2016-04-04 10:58:34 main INFO  [junit.node] initializing ...
2016-04-04 10:58:34 main DEBUG [junit.node] using config [target/config], data [[./target/es/data]], logs [/Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/target/es/log], plugins [target/plugins]
2016-04-04 10:58:34 main DEBUG [/Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/target/plugins] directory does not exist.
2016-04-04 10:58:34 main INFO  [junit.node] loaded [], sites []
2016-04-04 10:58:34 main DEBUG [junit.node] using node location [[NodePath{path=./target/es/data/junit.cluster/nodes/0, spins=null}]], local_node_id [0]
2016-04-04 10:58:34 main DEBUG [junit.node] node data locations details:
 -> /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/./target/es/data/junit.cluster/nodes/0, free_space [68.8gb], usable_space [68.6gb], total_space [232.6gb], spins? [unknown], mount [/ (/dev/disk1)], type [hfs]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [force_merge], type [fixed], size [1], queue_size [null]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [percolate], type [fixed], size [8], queue_size [1k]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [fetch_shard_started], type [scaling], min [1], size [16], keep_alive [5m]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [listener], type [fixed], size [4], queue_size [null]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [index], type [fixed], size [8], queue_size [200]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [refresh], type [scaling], min [1], size [4], keep_alive [5m]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [suggest], type [fixed], size [8], queue_size [1k]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [generic], type [cached], keep_alive [30s]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [warmer], type [scaling], min [1], size [4], keep_alive [5m]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [search], type [fixed], size [13], queue_size [1k]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [flush], type [scaling], min [1], size [4], keep_alive [5m]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [fetch_shard_store], type [scaling], min [1], size [16], keep_alive [5m]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [management], type [scaling], min [1], size [5], keep_alive [5m]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [get], type [fixed], size [8], queue_size [1k]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [bulk], type [fixed], size [8], queue_size [50]
2016-04-04 10:58:34 main DEBUG [junit.node] creating thread_pool [snapshot], type [scaling], min [1], size [4], keep_alive [5m]
2016-04-04 10:58:35 main DEBUG [junit.node] enabled [true], interval [1s], gc_threshold [{default=GcThreshold{name='default', warnThreshold=10000, infoThreshold=5000, debugThreshold=2000}, young=GcThreshold{name='young', warnThreshold=1000, infoThreshold=700, debugThreshold=400}, old=GcThreshold{name='old', warnThreshold=10000, infoThreshold=5000, debugThreshold=2000}}]
2016-04-04 10:58:35 main DEBUG [junit.node] Using probe [org.elasticsearch.monitor.os.OsProbe@48f4713c] with refresh_interval [1s]
2016-04-04 10:58:36 main DEBUG [junit.node] Using probe [org.elasticsearch.monitor.process.ProcessProbe@39e69ea7] with refresh_interval [1s]
2016-04-04 10:58:36 main DEBUG [junit.node] Using refresh_interval [1s]
2016-04-04 10:58:36 main DEBUG [junit.node] Using probe [org.elasticsearch.monitor.fs.FsProbe@43c87306] with refresh_interval [1s]
2016-04-04 10:58:36 main DEBUG [junit.node] creating [8] workers, queue_size [-1]
2016-04-04 10:58:36 main DEBUG [junit.node] using script cache with max_size [100], expire [null]
2016-04-04 10:58:36 main DEBUG [junit.node] using node_concurrent_recoveries [2], node_initial_primaries_recoveries [4]
2016-04-04 10:58:36 main DEBUG [junit.node] using [cluster_concurrent_rebalance] with [2]
2016-04-04 10:58:36 main DEBUG [junit.node] using [cluster.routing.allocation.allow_rebalance] with [indices_all_active]
2016-04-04 10:58:36 main DEBUG [junit.node] using initial_shards [quorum]
2016-04-04 10:58:36 main DEBUG configuration:

lo0
        inet 127.0.0.1 netmask:255.0.0.0 scope:host
        inet6 fe80::1 prefixlen:64 scope:link
        inet6 ::1 prefixlen:128 scope:host
        UP MULTICAST LOOPBACK mtu:16384 index:1

en1
        inet 192.168.0.11 netmask:255.255.255.0 broadcast:192.168.0.255 scope:site
        inet6 fe80::1240:f3ff:fe9d:c34 prefixlen:64 scope:link
        hardware 10:40:F3:9D:0C:34
        UP MULTICAST mtu:1500 index:5

vboxnet0
        inet 192.168.99.1 netmask:255.255.255.0 broadcast:192.168.99.255 scope:site
        hardware 0A:00:27:00:00:00
        UP MULTICAST mtu:1500 index:10

2016-04-04 10:58:36 main DEBUG using gathering [true]
2016-04-04 10:58:36 main DEBUG [junit.node] using max_chunk_size[8kb], max_header_size[8kb], max_initial_line_length[4kb], max_content_length[100mb], receive_predictor[512kb->512kb], pipelining[true], pipelining_max_events[10000]
2016-04-04 10:58:36 main DEBUG [junit.node] using max_bytes_per_sec[40mb], concurrent_streams [3], file_chunk_size [512kb], translog_size [512kb], translog_ops [1000], and compress [true]
2016-04-04 10:58:36 main DEBUG [junit.node] using indices.store.throttle.type [NONE], with index.store.throttle.max_bytes_per_sec [10gb]
2016-04-04 10:58:36 main DEBUG [junit.node] using indexing buffer size [182mb], with indices.memory.min_shard_index_buffer_size [4mb], indices.memory.max_shard_index_buffer_size [512mb], indices.memory.shard_inactive_time [5m], indices.memory.interval [30s]
2016-04-04 10:58:36 main DEBUG [junit.node] using [node] query cache with size [10%], actual_size [182mb], max filter count [1000]
2016-04-04 10:58:36 main DEBUG [junit.node] using size [-1] [-1b]
2016-04-04 10:58:36 main DEBUG [junit.node] took 0s to load state
2016-04-04 10:58:36 main INFO  [junit.node] initialized
2016-04-04 10:58:36 main INFO  [junit.node] starting ...
2016-04-04 10:58:36 main INFO  [junit.node] publish_address {local[1]}, bound_addresses {local[1]}
2016-04-04 10:58:36 main DEBUG [junit.node] Connected to cluster [Cluster [junit.cluster]]
2016-04-04 10:58:36 main INFO  [junit.node] junit.cluster/Q-TxtmHmTwOK1gyI_2TnCg
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-initial_connect(master)]: execute
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [1], source [local-disco-initial_connect(master)]
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] master {new {junit.node}{Q-TxtmHmTwOK1gyI_2TnCg}{local}{local[1]}{local=true}}, removed {{junit.node}{SwO7UUCNQ1SD1-CN4wxu6A}{local}{local[1]}{local=true},}, reason: local-disco-initial_connect(master)
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 1
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 1
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-initial_connect(master)]: took 4ms done applying updated cluster_state (version: 1, uuid: dJPZ4V2pTMqkfIc7qUgztg)
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [gateway_initial_state_recovery]: execute
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [gateway_initial_state_recovery]: took 1ms no change in cluster_state
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-gateway-elected-state]: execute
2016-04-04 10:58:36 main DEBUG Using select timeout of 500
2016-04-04 10:58:36 main DEBUG Epoll-bug workaround enabled = false
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [2], source [local-gateway-elected-state]
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 2
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 2
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] recovered [0] indices into cluster_state
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-gateway-elected-state]: took 85ms done applying updated cluster_state (version: 2, uuid: JthzUgZcSfa6b06OmrVGFw)
2016-04-04 10:58:36 main DEBUG [junit.node] Bound http to address {127.0.0.1:9200}
2016-04-04 10:58:36 main DEBUG [junit.node] Bound http to address {[fe80::1]:9200}
2016-04-04 10:58:36 main DEBUG [junit.node] Bound http to address {[::1]:9200}
2016-04-04 10:58:36 main INFO  [junit.node] publish_address {127.0.0.1:9200}, bound_addresses {127.0.0.1:9200}, {[fe80::1]:9200}, {[::1]:9200}
2016-04-04 10:58:36 main INFO  [junit.node] started
2016-04-04 10:58:36 main DEBUG Looking for templates in classpath under [es].
2016-04-04 10:58:36 main DEBUG Index [catalog] doesn't exist. Creating it.
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:36 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [3], source [create-index [catalog], cause [api]]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 3
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 3
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='aXWT2bKHTFOfCWehrWHYSw', shard=[catalog][0]}]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 589ms done applying updated cluster_state (version: 3, uuid: CeP9-Sg4Rtiv652212CoTw)
2016-04-04 10:58:37 main DEBUG Type [catalog]/[phone] doesn't exist. Creating it.
2016-04-04 10:58:37 main DEBUG Type definition for [catalog]/[phone] succesfully created.
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [423ms]
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=LrvpblP_SVSSDKnOb9IVow], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.015Z]], indexUUID [aXWT2bKHTFOfCWehrWHYSw], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:37 elasticsearch[junit.node][local_transport][T#3] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=LrvpblP_SVSSDKnOb9IVow], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.015Z]], indexUUID [aXWT2bKHTFOfCWehrWHYSw], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=LrvpblP_SVSSDKnOb9IVow], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.015Z]]), reason [after recovery from store]]: execute
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [4], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=LrvpblP_SVSSDKnOb9IVow], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.015Z]]), reason [after recovery from store]]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 4
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 4
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=LrvpblP_SVSSDKnOb9IVow], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.015Z]]), reason [after recovery from store]]: took 23ms done applying updated cluster_state (version: 4, uuid: 5cSAdkRNSx6DCn7A2aNjSg)
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [5], source [delete-index [catalog]]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 5
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 5
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 17ms done applying updated cluster_state (version: 5, uuid: zM5-QcD9RmaGl0cn6hYm-w)
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [6], source [create-index [catalog], cause [api]]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 6
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 6
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='_NfSoL9uRcSH-eqvGJvTZw', shard=[catalog][0]}]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 51ms done applying updated cluster_state (version: 6, uuid: 7bb0NYKLTf2OiBrnQOZfvA)
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [14ms]
2016-04-04 10:58:37 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=7xLetsJBTd-WTUMSguhKGA], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.916Z]], indexUUID [_NfSoL9uRcSH-eqvGJvTZw], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:37 elasticsearch[junit.node][local_transport][T#1] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=7xLetsJBTd-WTUMSguhKGA], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.916Z]], indexUUID [_NfSoL9uRcSH-eqvGJvTZw], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=7xLetsJBTd-WTUMSguhKGA], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.916Z]]), reason [after recovery from store]]: execute
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [7], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=7xLetsJBTd-WTUMSguhKGA], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.916Z]]), reason [after recovery from store]]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 7
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 7
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=7xLetsJBTd-WTUMSguhKGA], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:37.916Z]]), reason [after recovery from store]]: took 3ms done applying updated cluster_state (version: 7, uuid: pZMckJ_3QO6SfICQYMdLmA)
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:37 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG using decoder[VanillaChunkDecoder] 
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [8], source [put-mapping [phone]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 8
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 8
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 105ms done applying updated cluster_state (version: 8, uuid: s22dCke0RPajd8fr-yNK_w)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [9], source [delete-index [catalog]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 9
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 9
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 8ms done applying updated cluster_state (version: 9, uuid: 3DwHGFPARxa0DXqDbTaDLg)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [10], source [create-index [catalog], cause [api]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 10
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 10
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='8i09_-uVSL6qnsYhxP6LEQ', shard=[catalog][0]}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 40ms done applying updated cluster_state (version: 10, uuid: BRIdtBFNSiGu2vC9YZMhNg)
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [7ms]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=y7FK0N8HQkGzpRQ-jNHpOQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.487Z]], indexUUID [8i09_-uVSL6qnsYhxP6LEQ], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][local_transport][T#1] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=y7FK0N8HQkGzpRQ-jNHpOQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.487Z]], indexUUID [8i09_-uVSL6qnsYhxP6LEQ], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=y7FK0N8HQkGzpRQ-jNHpOQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.487Z]]), reason [after recovery from store]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [11], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=y7FK0N8HQkGzpRQ-jNHpOQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.487Z]]), reason [after recovery from store]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 11
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 11
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=y7FK0N8HQkGzpRQ-jNHpOQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.487Z]]), reason [after recovery from store]]: took 3ms done applying updated cluster_state (version: 11, uuid: LL9doHFyRq2gIZupay7imw)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [12], source [put-mapping [phone]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 12
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 12
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 8ms done applying updated cluster_state (version: 12, uuid: aJJz10kOQ8mocqvtALQEuw)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [13], source [delete-index [catalog]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 13
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 13
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 8ms done applying updated cluster_state (version: 13, uuid: O6u0mNNTRtyxm04AzsoMSA)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [14], source [create-index [catalog], cause [api]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 14
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 14
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='icMbsCysT7mbFBh57LsFRg', shard=[catalog][0]}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 34ms done applying updated cluster_state (version: 14, uuid: m_w9RohfSzu9bVTnSx00_A)
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [6ms]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=01TtgzuvSb2Zf9WFjlTh4A], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.599Z]], indexUUID [icMbsCysT7mbFBh57LsFRg], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][local_transport][T#1] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=01TtgzuvSb2Zf9WFjlTh4A], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.599Z]], indexUUID [icMbsCysT7mbFBh57LsFRg], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=01TtgzuvSb2Zf9WFjlTh4A], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.599Z]]), reason [after recovery from store]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [15], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=01TtgzuvSb2Zf9WFjlTh4A], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.599Z]]), reason [after recovery from store]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 15
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 15
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=01TtgzuvSb2Zf9WFjlTh4A], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.599Z]]), reason [after recovery from store]]: took 3ms done applying updated cluster_state (version: 15, uuid: d1EbQ793RYSIftB5q6cK0w)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [16], source [put-mapping [phone]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 16
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 16
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 9ms done applying updated cluster_state (version: 16, uuid: MgOeoK0cRCCAtsISgsB5_w)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [17], source [delete-index [catalog]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 17
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 17
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 7ms done applying updated cluster_state (version: 17, uuid: jhRm0wm-S_aCE2HprFsrzg)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [18], source [create-index [catalog], cause [api]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 18
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 18
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='shZbvlIiQTGPvxJnCBEg0A', shard=[catalog][0]}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 29ms done applying updated cluster_state (version: 18, uuid: PaJDVZODTniSdXStnuqIDw)
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [4ms]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=3hvc87NTS0yD7MBotyE1EQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.703Z]], indexUUID [shZbvlIiQTGPvxJnCBEg0A], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][local_transport][T#1] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=3hvc87NTS0yD7MBotyE1EQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.703Z]], indexUUID [shZbvlIiQTGPvxJnCBEg0A], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=3hvc87NTS0yD7MBotyE1EQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.703Z]]), reason [after recovery from store]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [19], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=3hvc87NTS0yD7MBotyE1EQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.703Z]]), reason [after recovery from store]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 19
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 19
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=3hvc87NTS0yD7MBotyE1EQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.703Z]]), reason [after recovery from store]]: took 2ms done applying updated cluster_state (version: 19, uuid: 3i2hpKrrSGWe5ncoJjXQnQ)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [20], source [put-mapping [phone]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 20
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 20
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 7ms done applying updated cluster_state (version: 20, uuid: ghjEdXR6S1aiy0dnvGlSKw)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [21], source [delete-index [catalog]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 21
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 21
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 7ms done applying updated cluster_state (version: 21, uuid: a-h1_jsgSMuSWV4ESMDkwg)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [22], source [create-index [catalog], cause [api]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 22
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 22
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='llP9LAcdQimjTFo6CRr2Bg', shard=[catalog][0]}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 26ms done applying updated cluster_state (version: 22, uuid: kXS6eW2GQX-U1_w3jRNPUQ)
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [5ms]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=mroVuYSJSoO3UroJ0yiZSQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.794Z]], indexUUID [llP9LAcdQimjTFo6CRr2Bg], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][local_transport][T#1] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=mroVuYSJSoO3UroJ0yiZSQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.794Z]], indexUUID [llP9LAcdQimjTFo6CRr2Bg], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=mroVuYSJSoO3UroJ0yiZSQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.794Z]]), reason [after recovery from store]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [23], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=mroVuYSJSoO3UroJ0yiZSQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.794Z]]), reason [after recovery from store]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 23
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 23
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=mroVuYSJSoO3UroJ0yiZSQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.794Z]]), reason [after recovery from store]]: took 3ms done applying updated cluster_state (version: 23, uuid: ea4oHNPNScWtJw7QXO41Zg)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [24], source [put-mapping [phone]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 24
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 24
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 6ms done applying updated cluster_state (version: 24, uuid: vZLBBA6oTYCi5LQBjOgAGw)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [25], source [delete-index [catalog]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 25
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 25
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 6ms done applying updated cluster_state (version: 25, uuid: CLCJ7hHiRq-fmmUAwGcpkQ)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [26], source [create-index [catalog], cause [api]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 26
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 26
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='EVP_0MZQQ-ar-qfOFFJqeg', shard=[catalog][0]}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 23ms done applying updated cluster_state (version: 26, uuid: KKZjUXbaSq28FGnVa7w2Eg)
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [5ms]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uRx6PlSzRn--vc_yYRdgLQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.887Z]], indexUUID [EVP_0MZQQ-ar-qfOFFJqeg], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][local_transport][T#7] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uRx6PlSzRn--vc_yYRdgLQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.887Z]], indexUUID [EVP_0MZQQ-ar-qfOFFJqeg], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uRx6PlSzRn--vc_yYRdgLQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.887Z]]), reason [after recovery from store]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [27], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uRx6PlSzRn--vc_yYRdgLQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.887Z]]), reason [after recovery from store]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 27
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 27
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uRx6PlSzRn--vc_yYRdgLQ], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.887Z]]), reason [after recovery from store]]: took 2ms done applying updated cluster_state (version: 27, uuid: b7ap2-e2Rey87nhnXcDo_g)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [28], source [put-mapping [phone]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 28
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 28
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 5ms done applying updated cluster_state (version: 28, uuid: 1nud6VPvQza-926emaJGbQ)
2016-04-04 10:58:38 main DEBUG [junit.node] the count api is deprecated and will be removed from the java api in the next major version
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [29], source [delete-index [catalog]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 29
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 29
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 6ms done applying updated cluster_state (version: 29, uuid: iB3zBPSkTACqDPDFLw-fdA)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [30], source [create-index [catalog], cause [api]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 30
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 30
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='PCOQUyy_TDGZt6bVQECWWw', shard=[catalog][0]}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 28ms done applying updated cluster_state (version: 30, uuid: wfOwcChCQPaa5fFBfu8Y5w)
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [7ms]
2016-04-04 10:58:38 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uilCfoMARzO0JXeLScrXVw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.962Z]], indexUUID [PCOQUyy_TDGZt6bVQECWWw], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][local_transport][T#7] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uilCfoMARzO0JXeLScrXVw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.962Z]], indexUUID [PCOQUyy_TDGZt6bVQECWWw], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uilCfoMARzO0JXeLScrXVw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.962Z]]), reason [after recovery from store]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [31], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uilCfoMARzO0JXeLScrXVw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.962Z]]), reason [after recovery from store]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 31
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 31
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=uilCfoMARzO0JXeLScrXVw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:38.962Z]]), reason [after recovery from store]]: took 2ms done applying updated cluster_state (version: 31, uuid: -Hquq2QwT_mi0aK-CQlAQg)
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [32], source [put-mapping [phone]]
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 32
2016-04-04 10:58:38 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 32
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 6ms done applying updated cluster_state (version: 32, uuid: bzTyH_stTJSSRgBETCyORQ)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [33], source [delete-index [catalog]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 33
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 33
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 6ms done applying updated cluster_state (version: 33, uuid: HtdHHBb-RvemEdy5IN_M4g)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [34], source [create-index [catalog], cause [api]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 34
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 34
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='QYiYg2L2T3uFMIM-UaMbBQ', shard=[catalog][0]}]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 19ms done applying updated cluster_state (version: 34, uuid: hnjWC8SxTFCqC7jyzy7anw)
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [4ms]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=6CyFjQA9S7mASPDVC6_vlw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.045Z]], indexUUID [QYiYg2L2T3uFMIM-UaMbBQ], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:39 elasticsearch[junit.node][local_transport][T#7] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=6CyFjQA9S7mASPDVC6_vlw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.045Z]], indexUUID [QYiYg2L2T3uFMIM-UaMbBQ], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=6CyFjQA9S7mASPDVC6_vlw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.045Z]]), reason [after recovery from store]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [35], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=6CyFjQA9S7mASPDVC6_vlw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.045Z]]), reason [after recovery from store]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 35
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 35
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=6CyFjQA9S7mASPDVC6_vlw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.045Z]]), reason [after recovery from store]]: took 2ms done applying updated cluster_state (version: 35, uuid: C53MkHx4TLm6vZ8ICbNaOQ)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [36], source [put-mapping [phone]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 36
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 36
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 5ms done applying updated cluster_state (version: 36, uuid: 5j2538lkR0GZq24Q9oJ_iQ)
Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 6.042 sec - in com.store.catalog.search.impl.ItemSearchDaoTest
Running com.store.catalog.service.catalog.impl.CatalogServiceImplTest
2016-04-04 10:58:39 main INFO  [junit.node] version[2.1.2], pid[9026], build[63c285e/2016-01-27T12:57:52Z]
2016-04-04 10:58:39 main INFO  [junit.node] initializing ...
2016-04-04 10:58:39 main DEBUG [junit.node] using config [target/config], data [[./target/es/data]], logs [/Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/target/es/log], plugins [target/plugins]
2016-04-04 10:58:39 main DEBUG [/Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/target/plugins] directory does not exist.
2016-04-04 10:58:39 main INFO  [junit.node] loaded [], sites []
2016-04-04 10:58:39 main DEBUG [junit.node] using node location [[NodePath{path=./target/es/data/junit.cluster/nodes/1, spins=null}]], local_node_id [1]
2016-04-04 10:58:39 main DEBUG [junit.node] node data locations details:
 -> /Users/zouheircadi/Google Drive/talks/2016/catalog/catalog-nosql/./target/es/data/junit.cluster/nodes/1, free_space [73.1gb], usable_space [72.9gb], total_space [232.6gb], spins? [unknown], mount [/ (/dev/disk1)], type [hfs]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [force_merge], type [fixed], size [1], queue_size [null]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [percolate], type [fixed], size [8], queue_size [1k]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [fetch_shard_started], type [scaling], min [1], size [16], keep_alive [5m]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [listener], type [fixed], size [4], queue_size [null]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [index], type [fixed], size [8], queue_size [200]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [refresh], type [scaling], min [1], size [4], keep_alive [5m]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [suggest], type [fixed], size [8], queue_size [1k]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [generic], type [cached], keep_alive [30s]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [warmer], type [scaling], min [1], size [4], keep_alive [5m]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [search], type [fixed], size [13], queue_size [1k]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [flush], type [scaling], min [1], size [4], keep_alive [5m]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [fetch_shard_store], type [scaling], min [1], size [16], keep_alive [5m]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [management], type [scaling], min [1], size [5], keep_alive [5m]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [get], type [fixed], size [8], queue_size [1k]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [bulk], type [fixed], size [8], queue_size [50]
2016-04-04 10:58:39 main DEBUG [junit.node] creating thread_pool [snapshot], type [scaling], min [1], size [4], keep_alive [5m]
2016-04-04 10:58:39 main DEBUG [junit.node] enabled [true], interval [1s], gc_threshold [{default=GcThreshold{name='default', warnThreshold=10000, infoThreshold=5000, debugThreshold=2000}, young=GcThreshold{name='young', warnThreshold=1000, infoThreshold=700, debugThreshold=400}, old=GcThreshold{name='old', warnThreshold=10000, infoThreshold=5000, debugThreshold=2000}}]
2016-04-04 10:58:39 main DEBUG [junit.node] Using probe [org.elasticsearch.monitor.os.OsProbe@48f4713c] with refresh_interval [1s]
2016-04-04 10:58:39 main DEBUG [junit.node] Using probe [org.elasticsearch.monitor.process.ProcessProbe@39e69ea7] with refresh_interval [1s]
2016-04-04 10:58:39 main DEBUG [junit.node] Using refresh_interval [1s]
2016-04-04 10:58:39 main DEBUG [junit.node] Using probe [org.elasticsearch.monitor.fs.FsProbe@647fb583] with refresh_interval [1s]
2016-04-04 10:58:39 main DEBUG [junit.node] creating [8] workers, queue_size [-1]
2016-04-04 10:58:39 main DEBUG [junit.node] using script cache with max_size [100], expire [null]
2016-04-04 10:58:39 main DEBUG [junit.node] using node_concurrent_recoveries [2], node_initial_primaries_recoveries [4]
2016-04-04 10:58:39 main DEBUG [junit.node] using [cluster_concurrent_rebalance] with [2]
2016-04-04 10:58:39 main DEBUG [junit.node] using [cluster.routing.allocation.allow_rebalance] with [indices_all_active]
2016-04-04 10:58:39 main DEBUG [junit.node] using initial_shards [quorum]
2016-04-04 10:58:39 main DEBUG configuration:

lo0
        inet 127.0.0.1 netmask:255.0.0.0 scope:host
        inet6 fe80::1 prefixlen:64 scope:link
        inet6 ::1 prefixlen:128 scope:host
        UP MULTICAST LOOPBACK mtu:16384 index:1

en1
        inet 192.168.0.11 netmask:255.255.255.0 broadcast:192.168.0.255 scope:site
        inet6 fe80::1240:f3ff:fe9d:c34 prefixlen:64 scope:link
        hardware 10:40:F3:9D:0C:34
        UP MULTICAST mtu:1500 index:5

vboxnet0
        inet 192.168.99.1 netmask:255.255.255.0 broadcast:192.168.99.255 scope:site
        hardware 0A:00:27:00:00:00
        UP MULTICAST mtu:1500 index:10

2016-04-04 10:58:39 main DEBUG [junit.node] using max_chunk_size[8kb], max_header_size[8kb], max_initial_line_length[4kb], max_content_length[100mb], receive_predictor[512kb->512kb], pipelining[true], pipelining_max_events[10000]
2016-04-04 10:58:39 main DEBUG [junit.node] using max_bytes_per_sec[40mb], concurrent_streams [3], file_chunk_size [512kb], translog_size [512kb], translog_ops [1000], and compress [true]
2016-04-04 10:58:39 main DEBUG [junit.node] using indices.store.throttle.type [NONE], with index.store.throttle.max_bytes_per_sec [10gb]
2016-04-04 10:58:39 main DEBUG [junit.node] using indexing buffer size [182mb], with indices.memory.min_shard_index_buffer_size [4mb], indices.memory.max_shard_index_buffer_size [512mb], indices.memory.shard_inactive_time [5m], indices.memory.interval [30s]
2016-04-04 10:58:39 main DEBUG [junit.node] using [node] query cache with size [10%], actual_size [182mb], max filter count [1000]
2016-04-04 10:58:39 main DEBUG [junit.node] using size [-1] [-1b]
2016-04-04 10:58:39 main DEBUG [junit.node] took 0s to load state
2016-04-04 10:58:39 main INFO  [junit.node] initialized
2016-04-04 10:58:39 main INFO  [junit.node] starting ...
2016-04-04 10:58:39 main INFO  [junit.node] publish_address {local[2]}, bound_addresses {local[2]}
2016-04-04 10:58:39 main DEBUG [junit.node] Connected to cluster [Cluster [junit.cluster]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco(detected_master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from node[{junit.node}{U4X0m4KIQU2BbbOR4Y9veg}{local}{local[2]}{local=true}])]: execute
2016-04-04 10:58:39 main INFO  [junit.node] junit.cluster/U4X0m4KIQU2BbbOR4Y9veg
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [0], source [local-disco(detected_master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [37], source [local-disco-receive(from node[{junit.node}{U4X0m4KIQU2BbbOR4Y9veg}{local}{local[2]}{local=true}])]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 0
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] added {{junit.node}{U4X0m4KIQU2BbbOR4Y9veg}{local}{local[2]}{local=true},}, reason: local-disco-receive(from node[{junit.node}{U4X0m4KIQU2BbbOR4Y9veg}{local}{local[2]}{local=true}])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 37
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco(detected_master)]: took 0s done applying updated cluster_state (version: 0, uuid: Q1BZPd-zQF2SisPb_fnsYw)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] got first state from fresh master [Q-TxtmHmTwOK1gyI_2TnCg]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [37], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] master {new {junit.node}{Q-TxtmHmTwOK1gyI_2TnCg}{local}{local[1]}{local=true}}, removed {{junit.node}{JIXzwWilRPGzBlU_CR75VQ}{local}{local[2]}{local=true},}, added {{junit.node}{Q-TxtmHmTwOK1gyI_2TnCg}{local}{local[1]}{local=true},}, reason: local-disco-receive(from master)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 37
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 37
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 4ms done applying updated cluster_state (version: 37, uuid: xANUxYMQQZqPWdkIKSbUig)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] data node was added, retrieving new cluster info
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [gateway_initial_state_recovery]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from node[{junit.node}{U4X0m4KIQU2BbbOR4Y9veg}{local}{local[2]}{local=true}])]: took 7ms done applying updated cluster_state (version: 37, uuid: xANUxYMQQZqPWdkIKSbUig)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [gateway_initial_state_recovery]: took 0s no change in cluster_state
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [cluster_reroute(post_node_add)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [cluster_reroute(post_node_add)]: took 0s no change in cluster_state
2016-04-04 10:58:39 main DEBUG [junit.node] Bound http to address {127.0.0.1:9201}
2016-04-04 10:58:39 main DEBUG [junit.node] Bound http to address {[fe80::1]:9201}
2016-04-04 10:58:39 main DEBUG [junit.node] Bound http to address {[::1]:9201}
2016-04-04 10:58:39 main INFO  [junit.node] publish_address {127.0.0.1:9201}, bound_addresses {127.0.0.1:9201}, {[fe80::1]:9201}, {[::1]:9201}
2016-04-04 10:58:39 main INFO  [junit.node] started
2016-04-04 10:58:39 main DEBUG Looking for templates in classpath under [es].
2016-04-04 10:58:39 main DEBUG Index [catalog] already exists.
2016-04-04 10:58:39 main DEBUG Type [catalog/phone] already exists and merge is not set.
2016-04-04 10:58:39 main DEBUG Type definition for [catalog]/[phone] succesfully merged.
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [38], source [delete-index [catalog]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 38
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 144 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [38], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 38
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [closed index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 38
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 38, uuid: WG-LmXmFTLanC1582TCD7A)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 13ms done applying updated cluster_state (version: 38, uuid: WG-LmXmFTLanC1582TCD7A)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [39], source [create-index [catalog], cause [api]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 39
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 407 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [39], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 39
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 39
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 39, uuid: Rx3vCyuoTBuBE8mER3TzwQ)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='uzomZxnXRxi_NtBRWVu63w', shard=[catalog][0]}]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 22ms done applying updated cluster_state (version: 39, uuid: Rx3vCyuoTBuBE8mER3TzwQ)
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [4ms]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=wasqZhMKQBWCkjxD6xu1Gg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.562Z]], expected_shard_size[7858], indexUUID [uzomZxnXRxi_NtBRWVu63w], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:39 elasticsearch[junit.node][local_transport][T#3] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=wasqZhMKQBWCkjxD6xu1Gg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.562Z]], expected_shard_size[7858], indexUUID [uzomZxnXRxi_NtBRWVu63w], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=wasqZhMKQBWCkjxD6xu1Gg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.562Z]], expected_shard_size[7858]), reason [after recovery from store]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [40], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=wasqZhMKQBWCkjxD6xu1Gg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.562Z]], expected_shard_size[7858]), reason [after recovery from store]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 40
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 208 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [40], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 40
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 40
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 40, uuid: erIPrTH5TrSmUzUZxTksqA)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=wasqZhMKQBWCkjxD6xu1Gg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.562Z]], expected_shard_size[7858]), reason [after recovery from store]]: took 5ms done applying updated cluster_state (version: 40, uuid: erIPrTH5TrSmUzUZxTksqA)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [41], source [put-mapping [phone]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 41
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 513 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [41], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 41
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 41
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 41, uuid: p-CiOiUFQKankwbRj_Y2MA)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 10ms done applying updated cluster_state (version: 41, uuid: p-CiOiUFQKankwbRj_Y2MA)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [42], source [delete-index [catalog]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 42
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 144 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [42], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 42
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [closed index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 42
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 42, uuid: 1u3_0QS4TaWuokw7OwbKVQ)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 7ms done applying updated cluster_state (version: 42, uuid: 1u3_0QS4TaWuokw7OwbKVQ)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [43], source [create-index [catalog], cause [api]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 43
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 407 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [43], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 43
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 43
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 43, uuid: DU5zPqa9QweBmMqQpX0IZg)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='_ZF7XSUCQQOme3t0h27Lpg', shard=[catalog][0]}]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 25ms done applying updated cluster_state (version: 43, uuid: DU5zPqa9QweBmMqQpX0IZg)
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [4ms]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=a1T4CsjqSg6N_v9VR5x_Mw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.645Z]], expected_shard_size[7858], indexUUID [_ZF7XSUCQQOme3t0h27Lpg], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:39 elasticsearch[junit.node][local_transport][T#2] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=a1T4CsjqSg6N_v9VR5x_Mw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.645Z]], expected_shard_size[7858], indexUUID [_ZF7XSUCQQOme3t0h27Lpg], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=a1T4CsjqSg6N_v9VR5x_Mw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.645Z]], expected_shard_size[7858]), reason [after recovery from store]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [44], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=a1T4CsjqSg6N_v9VR5x_Mw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.645Z]], expected_shard_size[7858]), reason [after recovery from store]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 44
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 208 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [44], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 44
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 0s done applying updated cluster_state (version: 44, uuid: HzawFpFrSI2FwNxAOyWLvw)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 44
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=a1T4CsjqSg6N_v9VR5x_Mw], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.645Z]], expected_shard_size[7858]), reason [after recovery from store]]: took 4ms done applying updated cluster_state (version: 44, uuid: HzawFpFrSI2FwNxAOyWLvw)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [45], source [put-mapping [phone]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 45
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 513 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [45], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 45
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 45
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 45, uuid: 5CINT01tQAKKDc3Prcf7cg)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 7ms done applying updated cluster_state (version: 45, uuid: 5CINT01tQAKKDc3Prcf7cg)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] deleting index
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [46], source [delete-index [catalog]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 46
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 144 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [46], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 46
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [closed index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 46
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 46, uuid: 1Ctvtk23TPm3_FlU409sFw)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] cleaning index, no longer part of the metadata
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [index no longer part of the metadata])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] deleting index store reason [index no longer part of the metadata]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog] processing pending deletes
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [delete-index [catalog]]: took 7ms done applying updated cluster_state (version: 46, uuid: 1Ctvtk23TPm3_FlU409sFw)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] INFO  [junit.node] [catalog] creating index, cause [api], templates [], shards [1]/[0], mappings []
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing ... (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index cache (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closing index service (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] closed... (reason [cleaning up after validating index on master])
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [47], source [create-index [catalog], cause [api]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 47
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 407 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [47], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 47
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 47, uuid: z_7XxiIjREyl_U_6q1uByg)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 47
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating index
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] creating Index [catalog], shards [1]/[0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using index.store.throttle.type [none], with index.store.throttle.max_bytes_per_sec [0b]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] using dynamic[false]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] creating shard
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] [catalog][0] creating using a new path [ShardPath{path=./target/es/data/junit.cluster/nodes/0/indices/catalog/0, indexUUID='RM_5UwtxSQe7AqUVpZfWvA', shard=[catalog][0]}]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] creating shard_id [catalog][0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] store stats are refreshed with refresh_interval [10s]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] Using [keep_only_last] deletion policy
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] using [tiered] merge mergePolicy with expunge_deletes_allowed[10.0], floor_segment[2mb], max_merge_at_once[10], max_merge_at_once_explicit[30], max_merged_segment[5gb], segments_per_tier[10.0], reclaim_deletes_weight[2.0]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] interval [5s], flush_threshold_ops [2147483647], flush_threshold_size [512mb], flush_threshold_period [30m]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [CREATED]->[RECOVERING], reason [from store]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] starting recovery from shard_store ...
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] recalculating shard indexing buffer, total is [182mb] with [1] active shards, each shard set to indexing=[182mb], translog=[64kb]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] updateBufferSize: engine is closed; skipping
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [create-index [catalog], cause [api]]: took 23ms done applying updated cluster_state (version: 47, uuid: z_7XxiIjREyl_U_6q1uByg)
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] wipe translog location - creating new translog
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] no translog ID present in the current generation - creating one
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] scheduling refresher every 1s
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] state: [RECOVERING]->[POST_RECOVERY], reason [post recovery from shard_store]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] recovery completed from [shard_store], took [4ms]
2016-04-04 10:58:39 elasticsearch[junit.node][generic][T#1] DEBUG [junit.node] [catalog][0] sending shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=aQXHpFuvS56TXfrbKqHgOg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.726Z]], expected_shard_size[7858], indexUUID [RM_5UwtxSQe7AqUVpZfWvA], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:39 elasticsearch[junit.node][local_transport][T#1] DEBUG [junit.node] received shard started for [catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=aQXHpFuvS56TXfrbKqHgOg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.726Z]], expected_shard_size[7858], indexUUID [RM_5UwtxSQe7AqUVpZfWvA], message [after recovery from store], failure [Unknown]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=aQXHpFuvS56TXfrbKqHgOg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.726Z]], expected_shard_size[7858]), reason [after recovery from store]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [48], source [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=aQXHpFuvS56TXfrbKqHgOg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.726Z]], expected_shard_size[7858]), reason [after recovery from store]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 48
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 208 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [48], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 48
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 48
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 0s done applying updated cluster_state (version: 48, uuid: Kabym4zHTvKXxkwn-_xvWQ)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog][0] state: [POST_RECOVERY]->[STARTED], reason [global state is [STARTED]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [shard-started ([catalog][0], node[Q-TxtmHmTwOK1gyI_2TnCg], [P], v[1], s[INITIALIZING], a[id=aQXHpFuvS56TXfrbKqHgOg], unassigned_info[[reason=INDEX_CREATED], at[2016-04-04T08:58:39.726Z]], expected_shard_size[7858]), reason [after recovery from store]]: took 5ms done applying updated cluster_state (version: 48, uuid: Kabym4zHTvKXxkwn-_xvWQ)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] [catalog] create_mapping [phone] with source [{"phone":{"dynamic":"strict","properties":{"age":{"type":"integer","store":true},"id":{"type":"string","index":"not_analyzed","store":true},"imageUrl":{"type":"string","store":true},"name":{"type":"string","store":true},"snippet":{"type":"string","store":true}}}}]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [49], source [put-mapping [phone]]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] publishing cluster state version 49
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] sending diff cluster state version with size 513 to [junit.node]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: execute
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] cluster state updated, version [49], source [local-disco-receive(from master)]
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 49
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] set local cluster state to version 49
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [local-disco-receive(from master)]: took 1ms done applying updated cluster_state (version: 49, uuid: u9XXTBkBQiyizawHEW6L-A)
2016-04-04 10:58:39 elasticsearch[junit.node][clusterService#updateTask][T#1] DEBUG [junit.node] processing [put-mapping [phone]]: took 7ms done applying updated cluster_state (version: 49, uuid: u9XXTBkBQiyizawHEW6L-A)
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.676 sec - in com.store.catalog.service.catalog.impl.CatalogServiceImplTest
2016-04-04 10:58:39 Thread-1 INFO  [junit.node] stopping ...
2016-04-04 10:58:39 Thread-2 INFO  [junit.node] stopping ...
2016-04-04 10:58:39 Thread-2 INFO  [junit.node] stopped
2016-04-04 10:58:39 Thread-2 INFO  [junit.node] closing ...
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] closing ... (reason [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] closing index service (reason [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] [0] closing... (reason: [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog][0] state: [STARTED]->[CLOSED], reason [shutdown]
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog][0] operations counter reached 0, will not accept any further writes
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog][0] flushing shard on close - this might take some time to sync files to disk
2016-04-04 10:58:39 Thread-2 INFO  [junit.node] closed
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog][0] close now acquiring writeLock
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog][0] close acquired writeLock
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog][0] translog closed
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog][0] engine closed [api]
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog][0] store reference count on close: 0
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] [0] closed (reason: [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] closing index cache (reason [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] full cache clear, reason [close]
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] clearing all bitsets because [close]
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] clearing index field data (reason [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] closing analysis service (reason [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] closing mapper service (reason [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] closing index query parser service (reason [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] closing index service (reason [shutdown])
2016-04-04 10:58:39 indices_shutdown[T#1] DEBUG [junit.node] [catalog] closed... (reason [shutdown])
2016-04-04 10:58:39 Thread-1 INFO  [junit.node] stopped
2016-04-04 10:58:39 Thread-1 INFO  [junit.node] closing ...
2016-04-04 10:58:39 Thread-1 INFO  [junit.node] closed

Results :

Tests run: 11, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 11.730 s
[INFO] Finished at: 2016-04-04T10:58:40+02:00
[INFO] Final Memory: 31M/222M
[INFO] ------------------------------------------------------------------------
